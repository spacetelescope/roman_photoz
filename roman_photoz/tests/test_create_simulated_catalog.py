from unittest.mock import MagicMock, patch

import numpy as np
import pytest
from numpy.lib.recfunctions import merge_arrays

from roman_photoz.create_simulated_catalog import SimulatedCatalog
from roman_photoz.default_config_file import default_roman_config
from roman_photoz.utils.roman_photoz_utils import get_roman_filter_list

FILTER_LIST = get_roman_filter_list()


@pytest.fixture
def simulated_catalog():
    return SimulatedCatalog(nobj=100)


def test_is_folder_not_empty(simulated_catalog):
    with (
        patch("pathlib.Path.exists", return_value=True),
        patch("pathlib.Path.is_dir", return_value=True),
        patch("pathlib.Path.glob", return_value=["file1", "file2"]),
    ):
        assert simulated_catalog.is_folder_not_empty("dummy_path", "file") is True

    with patch("pathlib.Path.exists", return_value=False):
        assert simulated_catalog.is_folder_not_empty("dummy_path", "file") is False
    with patch("pathlib.Path.is_dir", return_value=False):
        assert simulated_catalog.is_folder_not_empty("dummy_path", "file") is False
    with patch("pathlib.Path.glob", return_value=[]):
        assert simulated_catalog.is_folder_not_empty("dummy_path", "file") is False


def test_add_ids(simulated_catalog):
    catalog = np.array([(1.0, 2.0), (3.0, 4.0)], dtype=[("col1", "f8"), ("col2", "f8")])
    updated_catalog = simulated_catalog.add_ids(catalog)
    assert "label" in updated_catalog.dtype.names
    assert np.array_equal(updated_catalog["label"], [1, 2])


@pytest.mark.parametrize(
    "params",
    [
        {"mag_noise": 0.1},
        {"mag_noise": 0.2},
        {"mag_noise": 0.05},
    ],
)
def test_add_error(simulated_catalog, params):
    catalog = np.array([(1.0, 2.0)], dtype=[("mag1", "f8"), ("mag2", "f8")])
    updated_catalog = simulated_catalog.add_error(
        catalog, mag_noise=params["mag_noise"], seed=123
    )
    # ensure that the new columns are added and values are within the expected range
    assert "mag1_err" in updated_catalog.dtype.names
    assert "mag2_err" in updated_catalog.dtype.names
    assert updated_catalog["mag1_err"][0] == params["mag_noise"]
    assert updated_catalog["mag2_err"][0] == params["mag_noise"]
    # ensure that noise has been added to the original magnitudes
    assert np.all(updated_catalog["mag1"] != catalog["mag1"])
    assert np.all(updated_catalog["mag2"] != catalog["mag2"])


def test_pick_random_lines(simulated_catalog):
    simulated_catalog.simulated_data = np.array(
        [(1.0, 2.0), (3.0, 4.0), (5.0, 6.0)], dtype=[("col1", "f8"), ("col2", "f8")]
    )
    random_lines = simulated_catalog.pick_random_lines(2)
    assert len(random_lines) == 2


def test_create_header(simulated_catalog):
    # create a mock header as generated by lephare.prepare()
    mock_file_content = (
        "# model ext_law E(B-V) age N_filt magnitude[N_filt] kcorr[N_filt]"
    )
    with patch("builtins.open", new_callable=MagicMock) as mock_open:
        mock_open.return_value.__enter__.return_value.readline.return_value = (
            mock_file_content
        )
        colnames = simulated_catalog.create_header("dummy_catalog")
    # check that we have expanded the columns with _vector suffix into multiple columns (one for each filter)
    assert all(f"magnitude{filter}" in colnames for filter in FILTER_LIST)
    assert all(f"kcorr{filter}" in colnames for filter in FILTER_LIST)


def test_process(simulated_catalog):
    with (
        patch.object(
            simulated_catalog, "create_filter_files"
        ) as mock_create_filter_files,
        patch.object(
            simulated_catalog, "create_simulated_data"
        ) as mock_create_simulated_data,
        patch.object(
            simulated_catalog, "create_simulated_input_catalog"
        ) as mock_create_simulated_input_catalog,
    ):
        simulated_catalog.process(
            output_path="dummy_path", output_filename="dummy_file"
        )
        mock_create_filter_files.assert_called_once()
        mock_create_simulated_data.assert_called_once()
        mock_create_simulated_input_catalog.assert_called_once()
